@startuml Indie_Studio

'Gestion de souris, manettes, clavier, fps, fichier (sauvegarde), parsing JSON, textures
'texte, drawShapes, models(2d, 3D), audio

namespace global {
    class Vector<T> {
        +Vector(T x, T y)
        +~Vector() = default;
        +const Vector(const Vector &copy);
        +bool operator==();
        +bool operator!=();
        +Vector &operator+();
        +Vector &operator-();

        -T _x;
        -T _y;
    }
}

namespace game {
        enum EntityType {
        COLLECTABLE,
        DROPPABLE,
        BOMB,
        POWERUP,
        PLAYER,
        AI
    }

    class Character extends game.Systems.Moveable, game.Systems.Animable {
        -std::string _name;
    }

    class AI {
    }

    class Player extends game.Character {
        -std::string _id;
        -size_t _score;
    }

    class Bot extends game.Character, game.AI {

    }

}

namespace game.Scenes {
    class MainMenu implements gameEngine.Interfaces.IScene {
        -game.Managers.ButtonManager _buttonManager;
    }
}

namespace game.Systems {
    class Moveable {
        +Move(Vector &pos, Vector speed = {1,1});
        +~Move();
        +void moveUp();
        +void moveDown();
        +void moveLeft();
        +void moveRight();
        +Vector getSpeed();
        +void setSpeed(Vector &);

        -Vector _pos;
        -Vector _speed;
    }

    class Animable {
        +Animable();
        +~Animable();

        +void loadAnim();
        +ModelAnimation *loadModelAnimation();
        +void updateModelAnimation();
        +void unloadModelAnimation();
        +bool isModelAnimationValid();

        -ModelAnimation *_animation;
    }

    class Collision {

    }

    class Explosion {

    }
}

namespace game.Managers {

    class SaveManager implements gameEngine.Interfaces.AFileManager{}
    class MeshManager{}
    class TextureManager implements gameEngine.Interfaces.ITextureManager {}
    class TextManager implements gameEngine.Interfaces.ITextManager {}
    class WindowManager implements gameEngine.Interfaces.IWindowManager {}
    class ObjFileManager implements gameEngine.Interfaces.AFileManager {}
    class SceneManager{}
    class GameManager{}

    'Button args are taken from botttom to top
    class ButtonManager {
        +bool isButtonClicked(Vector pos);
        +Button createButton(std::tuple<Vector, Vector, std::string, Font, Color, Color, Color, Rectangle> buttonInfo);
        +bool isButtonClicked(std::string button_content);
        -std::vector<Button> _currentButtons;
    }
}

namespace game.Objects {

    class GameObject {
        int getId();
        int id
    }
    class Droppable extends GameObject {}
    class Collectible extends GameObject {}
    class Bomb extends Droppable {}

    enum TileType {
        WALL,
        PATH,
    }
    class Tile extends GameObject {
        -Texture _texture;
        -Vector _pos;
        -TileType _type;
    }

    class Map {
        -std::vector<std::vector<Tile>> _tiles;
    }

    class Wall extends GameObject {
        +Wall(bool isDestructible)

        -bool _isDestructible;
    }

    class Mine extends game.Objects.Droppable {}
    class HealthPack extends game.Objects.Collectible {}

}

namespace gameEngine {
    class Button {
        -Rectangle _border;
        -Color _borderColor;
        -Color _fontColor;
        -Color _backgroundColor;
        -Front _font;
        -std::string _content;
        -Vector _size;
        -Vector _pos;
    }


namespace Encapsulation #fc7c60  {
    class Image {}
    class Camera {}

    'Demander une precision a Julien, et remplir les class par rapport a la raylib
    class Model {
        +Model(const std::string &);
        +~Model();
        +Model loadModel(const std::string &);

        -std::string _path;
    }
    class Button {}
    class Camera2d {}
    class Shader {}
    class Mesh {}
    class Music {}
    class Sound {}
    class Color {}

    class Font {
        +Font(const std::string &path);
        +~Font();
        -std::string _path;
    }

    class Rectangle {}
    class Socket {}

    class Animation {
        +Animation(Model, ModelAnimation, size_t = 0);
        +~Animation();
        +ModelAnimation *loadModelAnimation(const std::string &, int *animCount);
        +void updateModelAnimation(Model, ModelAnimation, int);
        +void unloadModelAnimation(ModelAnimation *, unsigned int);
        +bool isModelAnimationValid(Model, ModelAnimation);
        -Model _model;
        -size_t _frameCounter;
        -ModelAnimation *_animation;
    }
}

namespace Interfaces #DDDDDD {

    interface IScene
    {
        +void loadScene();
        +void destroyScene();
    }

    interface IWindowManager
    {
        +void createWindow(Vector<int> size, const std::string &title);
        +void openWindow();
        +void closeWindow();
        +void clearWindow();
        +void updateWindow();
        +void toggleFullscreen();

        -Vector &getScreenSize();
        -Vector &getWindowPos();
    }

    interface IDrawManager
    {
        +void drawCircle(const float radius, );
        +void drawRect(const Vector &size, size_t radius);
        +void drawLine(const Vector &size);
        +void drawGrid(const Vector &size, int nbCols, int nbRows);
    }

    interface ITextureManager
    {
        +void setTexture();
        +void loadTexture();
        +void uploadTexture();
        +void drawTextureRect();
        'Potentiellement ajouter + de drawTexture
        +void destroyTexture();
    }

    interface ITextManager
    {
        +void drawText(const Font &f);
        +void drawTextInRect(const Font &f, const std::string &text, const Vector<float> &offset, Rectangle rect);
    }

    interface IAudioManager
    {
        'Classe audio avec playlist
        +void PlaySound(const Sound &);
        +void PlayMusic(const Music &);
        +Sound LoadSound(const std::string &);
        +Music LoadMusic(const std::string &);
        +bool isMusicPlaying(const Music &);
        +void PauseMusic(const Music &);
        +void setMusicVolume(const Music &, float);
        +void DestroySound(Sound &);
        +void DestroyMusic(Sound &);
    }

    'Definir un port
    'A completer, poser des questions sur les attentes et ce qu'on
    'Voir rush2 SantaServer de Polo
    interface INetworkManager
    {
        +void connect(const Socket &);
        +void createSocket(int);
        +void disconnect(const Socker &);
        +void sendInfo(const std::string &, const Socket &In, const Socker &Out);

    }

    abstract class AFileManager implements IFileManager {}
    
    'Classe qui pourrait herite de IFileManager -> JsonManager, XMLManager, OBJFileManager, ConfigManager, SaveManager
    interface IFileManager
    {
        +bool checkFileExist(const std::string &);
        +bool checkFilePermissions(const std::string &);
        +File loadFile(const std::string &);
        +void CloseFile(File &);
        +std::string readFile(const File &);
        +std::vector<std::string> readFile(const File &);
        +std::string getFileName(const File &);
        +std::string getFilePath(const File &);
        +std::vector<std::string> getDirectoryFiles(const File &);
    }

    'Mapper std::map<Key, int Code> pareil pour manette
    'Classe qui pourrait herite: Keyboard, Gamepad, Mouse
    interface IInputManager
    {
        +bool isKeyPressed(int);
        +bool isKeyReleased(int);
        +int getKeyPressed();
    }
    'Voir pour les collisions si interface necessaires
}
}
@enduml
